package parallel;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import org.apache.log4j.Logger;
import grph.properties.NumericalProperty;
import pt.*;
import alg.Algorithm;
import toools.collections.primitive.LucIntSet;
import util.PartialScheduleGrph;
import util.ScheduleGrph;
import java.util.HashSet;
/**
 * A basic cost parallel function that assigns the end time as the cost.
 * 
 * @author Nikhil
 *
 */
public class CostFunctionParallel  {

	ScheduleGrph input;
	final static Logger log = Logger.getLogger(Algorithm.class);
	public CostFunctionParallel(ScheduleGrph input) {
		this.input = input;
	}

	
	TASK public HashSet<Integer> getFree(ScheduleGrph inputSaved, PartialScheduleGrph pg,int task,HashSet<Integer> a) {
		/*
		 * iterate over tasks in the partial schedule, and add to output ones
		 * that are free and not contained in the current partial
		 */
		 long start = System.currentTimeMillis();
		 boolean add = true;
			for (int outEdge : inputSaved.getOutEdges(task)) {
				int otherVert = inputSaved.getTheOtherVertex(outEdge, task);
				// check that not contained in current
				if (!pg.containsVertex(otherVert)) {
					 add = true;
					// check that dependencies are satisfied.
					for (int e : inputSaved.getInEdges(otherVert)) {
						if (!pg.containsVertex(inputSaved.getTheOtherVertex(e, otherVert))) {
							add = false;
							break;
						}
					}
					if (add) {
						 long time = System.currentTimeMillis() - start;
				         long id = Thread.currentThread().getId();
				         log.info(otherVert + "added: " + add +"\' [" + (time / 1000.0) + " seconds, thread "+id+"]");
				         a.add(otherVert);
					}
				}
			}
			return a;
	}
}
