package parallel;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import org.apache.log4j.Logger;
import grph.properties.NumericalProperty;
import pt.*;
import java.util.Set;
import java.util.PriorityQueue;
import alg.Algorithm;
import toools.collections.primitive.LucIntSet;
import util.PartialScheduleGrph;
import util.ScheduleGrph;
import java.util.HashSet;
import util.ScheduleDotWriter;
/**
 * A basic cost parallel function that assigns the end time as the cost.
 * 
 * @author Nikhil
 *
 */
public class GetFreeVerticesParallel  {

	ScheduleGrph input;
	final static Logger log = Logger.getLogger(Algorithm.class);
	public GetFreeVerticesParallel(ScheduleGrph input) {
		this.input = input;
	}
	public GetFreeVerticesParallel() {
	}


	
	IO_TASK public HashSet<Integer> getFree(ScheduleGrph inputSaved, PartialScheduleGrph pg,int task,HashSet<Integer> a) {
		/*
		 * iterate over tasks in the partial schedule, and add to output ones
		 * that are free and not contained in the current partial
		 */
		 long start = System.currentTimeMillis();
		 boolean add = true;
			for (int outEdge : inputSaved.getOutEdges(task)) {
				int otherVert = inputSaved.getTheOtherVertex(outEdge, task);
				// check that not contained in current
				if (!pg.containsVertex(otherVert)) {
					 add = true;
					// check that dependencies are satisfied.
					for (int e : inputSaved.getInEdges(otherVert)) {
						if (!pg.containsVertex(inputSaved.getTheOtherVertex(e, otherVert))) {
							add = false;
							break;
						}
					}
					if (add) {
				         long id = Thread.currentThread().getId();
				         a.add(otherVert);
					}
				}
			}
			return a;
	}
	
	TASK public PriorityQueue<PartialScheduleGrph> getCosts(int numProcessors,PriorityQueue<PartialScheduleGrph> states,int task,PartialScheduleGrph s,HashSet<String> closedStates) {
		for (int pc = 1; pc <= numProcessors; pc++) {
			long start = System.currentTimeMillis();
			PartialScheduleGrph next = s.copy();
			next.addVertex(task);
			next.getVertexWeightProperty().setValue(task, input.getVertexWeightProperty().getValue(task));
			next.getVertexProcessorProperty().setValue(task, pc);

			// set the start time based on earliest first on a
			// processor

			// to get the start time, find the time of most
			// recently
			// finishing vertex on the same processor,
			// and store that, also the finish time of the last
			// dependency. starting time would be the maximum\
			// of the two.
			int dependencyUpperBound = 0;
			for (int taskDp : input.getInNeighbours(task)) {
				int edgeTime = 0;
				if (next.getVertexProcessorProperty().getValue(taskDp) != pc) {
					edgeTime = (int) input.getEdgeWeightProperty()
							.getValue(input.getSomeEdgeConnecting(taskDp, task));
				}

				int totalTime = (int) (input.getVertexWeightProperty().getValue(taskDp)
						// needs to be next, not input for start
						+ next.getVertexStartProperty().getValue(taskDp) + edgeTime);
				if (totalTime > dependencyUpperBound) {
					dependencyUpperBound = totalTime;
				}
			}

			/**
			 * find the latest finishing process on the same
			 * processor, and factor into the timing
			 * 
			 * TODO make this a function of the PartialScheduleGrph
			 * to suit the abstraction Named
			 * getProcessorFinishTime() ??
			 */
			int processorUpperBound = 0;
			for (int pcTask : next.getVertices()) {
				if (next.getVertexProcessorProperty().getValue(pcTask) == pc && pcTask != task) {
					int totalTime = (int) (next.getVertexWeightProperty().getValue(pcTask)
							+ next.getVertexStartProperty().getValue(pcTask));
					if (totalTime > processorUpperBound) {
						processorUpperBound = totalTime;
					}

				}
			}

			// find the maximum time the task can start on a
			// processor.
			next.getVertexStartProperty().setValue(task,
					Math.max(processorUpperBound, dependencyUpperBound));

			// log.info(next.toDot());
			if (!storedInClosedSet(next.getNormalizedCopy(numProcessors), closedStates)) {
				states.add(next);
			}
			
		}
		return states;
	}
	private boolean storedInClosedSet(PartialScheduleGrph g, Set<String> closedStates) {
		// long start = System.currentTimeMillis();
		String serialized = new ScheduleDotWriter().createDotText(g, false);
		// serializeTime += System.currentTimeMillis() - start;
		return closedStates.contains(serialized);
	}
}
